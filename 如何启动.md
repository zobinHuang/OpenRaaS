## 配置环境

### Linux 环境

> Provider

```
sudo apt-get install -y jq curl expect davfs2 iperf

# 如果有 nvidia 显卡
apt-get install nvidia-container-runtime
```

### Docker & docker-compose

> Scheduler, Provider, Filestore, Depository

```bash

# 1. install docker by script

cd ~/Downloads/
curl -fsSL get.docker.com -o get-docker.sh
sudo sh get-docker.sh --mirror Aliyun

# 2. directly install docker-compose into /usr/local/bin/

sudo curl -L "https://github.com/docker/compose/releases/download/v2.6.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

```

### Golang

> Provider

```bash
# 获取 go 并解压到 /usr/local
wget https://studygolang.com/dl/golang/go1.17.5.linux-amd64.tar.gz
sudo tar xfz go1.17.5.linux-amd64.tar.gz -C /usr/local

# 编辑系统配置文件
vim ~/.bashrc

# 配置 goroot（go 的安装目录），gopath（工作目录，放代码的地方，可自定义）
export GOROOT=/usr/local/go  
export GOPATH=~/Code
export PATH=$PATH:$GOROOT/bin 

# 重新执行初始化文件使修改后的新配置立即生效
source ~/.bashrc
```

### Nodejs

```bash
sudo apt update
sudo apt install nodejs npm
```

> Scheduler

## 1. 在 scheduler 节点上启动前端

```
cd web/ant-client-page
npm install
npm start
```

## 2. 在 scheduler 节点上启动 Nginx

Modify Nginx configuration file at <code>nginx/conf.d/static.conf</code>:

```nginx
upstream backstage{
    server [Ip and port of Global Master];
}

upstream web{
    server [Ip and port of Web frontend server];
}

server{
    listen 80;
    server_name [Server Domain];

    ...
```

Run OpenRaaS Nginx proxy:

```bash
sudo docker run --name nginx \
    --restart always \
    -p 80:80 \
    -v /home/broscloud/Code/OpenRaaS/nginx/logs:/var/log/nginx \
    -v /home/broscloud/Code/OpenRaaS/nginx/nginx.conf:/etc/nginx/nginx.conf \
    -v /home/broscloud/Code/OpenRaaS/nginx/conf.d:/etc/nginx/conf.d \
    -d nginx
```

## 3. 在 scheduler 节点上启动后端

```bash
cd backstage
sudo docker-compose up
```

## 4. 在 provider 节点上启动 serverd

注意，provider 中有两个后台进程，streamer 与 serverd：
- streamer 用于建立 user 与应用实例（容器）之间的 WebRTC 与 WebSocket 链接，同时由它直接与 scheduler 交互（包括节点上线）
- serverd 就是 provider 上的 daemon 程序，负责在 streamer 的调度下启动、管理、关闭应用实例（容器），并完成与 filestore、depository 的服务组合，同时由它来启动 streamer

因此，我们只需要启动 serverd 即可完成 provider 的部署

如果 `serverd` 二进制文件已经编译：

```bash
cd provider/serverd
sudo ./serverd
```

如果需要重新编译 `serverd` 文件：

1. 如果有，就先删掉 `go.mod` 和 `go.sum`
2. 运行 `go mod init serverd` 和 `go mod tidy`
3. 运行 `go build`
4. 运行 `sudo ./serverd` 二进制文件

注意，如果使用默认的 depository 启动 registry，由于没有配置 HTTPS，需要在 provider 上手动切换 Docker 拉取命令为 HTTP：

```bash
cd ./provider

# 修改 INSECURE_REGISTRIES 数组，将要信任的 depository ip 与 port 填入

sudo bash add_insecure_registries.sh
```

## 5. 在 filestore 节点上启动 daemon

```bash
cd filestore
sudo docker-compose up
```

## 6. 在 depository 节点上启动 daemon

```bash
cd depository
sudo docker-compose up
```

## 5. 在 filestore 节点配置 APP

首先将包含 APP 的文件夹移动到 `./filesotre/storage` 中，然后配置 `./filestore/app_online/config.yaml`，注意每个 APP 的信息以 "app{编号}_" 开头，编号从 1 开始

```yaml
name: APP 名称（自定义）
path: 包含 APP 可执行文件的文件夹在 `./storage` 目录下的相对路径
file: APP 文件夹下的可执行文件名
hwkey: APP 类型，传入 "game" 或 "app"
os: 操作系统
create_user: 上传该 APP 的用户
description: 对 APP 的描述信息（自定义）
provider_performance: 对计算的要求，true-高性能，false-低性能
filestore_performance: 对数据存储的要求，true-高性能，false-低性能
depository_performance: 对镜像存储的要求，true-高性能，false-低性能
```


## 其他

一定要记得配置三个节点的 scheduler 设置，可以考虑写一个一键修改的脚本。

- Provider: `./provider/streamer/.env.dev`, `./provider/serverd/config`
    - [@zobinHuang](github.com/zobinHuang) 写的太乱了，streamer 上有些 scheduler 信息来自 serverd 的通知，有些又是用 os.Getenv 从 .env.dev 读出来的 
- Filestore: `./filestore/daemon/config.yaml`
- Depository: `./depository/daemon/config.yaml`

如果要改 scheduler 的 IP：

- 首先改 `./nginx/conf.d/static.conf` 里的 nginx 的配置文件
- 然后改 docker-compose 里的 traefik 配置文件

清理数据库：`curl "http://kb109.dynv6.net:52109/api/scheduler/clear" -X POST`